"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TRIGGERX_SAFE_FACTORY_ABI = void 0;
exports.createSafeWalletForUser = createSafeWalletForUser;
const ethers_1 = require("ethers");
// Minimal ABI for TriggerXSafeFactory
exports.TRIGGERX_SAFE_FACTORY_ABI = [
    "function createSafeWallet(address user) returns (address)",
    "function latestSafeWallet(address user) view returns (address)",
    "function getSafeWallets(address user) view returns (address[])",
    "function predictSafeAddress(address user) view returns (address)",
    "event SafeWalletCreated(address indexed user, address indexed safeWallet, uint256 saltNonce)"
];
async function createSafeWalletForUser(factoryAddress, signer, user) {
    const factory = new ethers_1.ethers.Contract(factoryAddress, exports.TRIGGERX_SAFE_FACTORY_ABI, signer);
    const tx = await factory.createSafeWallet(user);
    const receipt = await tx.wait();
    // Try to fetch from event; fallback to latestSafeWallet
    const evt = receipt.logs
        .map((l) => {
        try {
            return factory.interface.parseLog(l);
        }
        catch {
            return null;
        }
    })
        .find((e) => e && e.name === 'SafeWalletCreated');
    let safeAddress;
    if (evt && evt.args && evt.args.safeWallet) {
        safeAddress = evt.args.safeWallet;
    }
    else {
        safeAddress = await factory.latestSafeWallet(user);
    }
    // Wait a bit for the Safe contract to be fully initialized
    // This is important because Safe proxy contracts need time to be set up
    await new Promise(resolve => setTimeout(resolve, 2000));
    return safeAddress;
}
