"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkTgBalance = void 0;
const ethers_1 = require("ethers");
const GasRegistry_json_1 = __importDefault(require("../contracts/abi/GasRegistry.json"));
const config_1 = require("../config");
const errors_1 = require("../utils/errors");
const checkTgBalance = async (signer) => {
    // Validate inputs
    if (!signer) {
        return (0, errors_1.createErrorResponse)(new errors_1.ValidationError('signer', 'Signer is required'), 'Validation error');
    }
    try {
        const network = await signer.provider?.getNetwork();
        const chainId = network?.chainId ? network.chainId.toString() : undefined;
        const { gasRegistry } = (0, config_1.getChainAddresses)(chainId);
        const gasRegistryContractAddress = gasRegistry;
        if (!gasRegistryContractAddress) {
            return (0, errors_1.createErrorResponse)(new errors_1.ConfigurationError(`GasRegistry address not configured for chain ID: ${chainId}`), 'Configuration error');
        }
        const contract = new ethers_1.ethers.Contract(gasRegistryContractAddress, GasRegistry_json_1.default, signer);
        const address = await signer.getAddress();
        const balance = await contract.balances(address);
        // balance is likely an array or object with ethSpent and TGbalance, both in wei
        // We'll convert TGbalance from wei to ETH
        // If balance is an array: [ethSpent, TGbalance]
        // If balance is an object: { ethSpent, TGbalance }
        let tgBalanceWei;
        if (Array.isArray(balance)) {
            tgBalanceWei = balance[1];
        }
        else if (balance && balance.TGbalance !== undefined) {
            tgBalanceWei = balance.TGbalance;
        }
        else {
            return (0, errors_1.createErrorResponse)(new errors_1.ContractError('Unexpected balance format from contract', { balance }), 'Contract error');
        }
        const tgBalance = ethers_1.ethers.formatEther(tgBalanceWei);
        console.log('tgBalanceEth', tgBalance);
        return { success: true, data: { tgBalanceWei, tgBalance } };
    }
    catch (error) {
        console.error('Error checking TG balance:', error);
        if (error instanceof Error) {
            if (error.message.includes('network') || error.message.includes('timeout')) {
                return (0, errors_1.createErrorResponse)(new errors_1.NetworkError('Network error during balance check', { originalError: error }), 'Network error');
            }
            else if (error.message.includes('contract') || error.message.includes('transaction')) {
                return (0, errors_1.createErrorResponse)(new errors_1.ContractError('Contract error during balance check', { originalError: error }), 'Contract error');
            }
        }
        return (0, errors_1.createErrorResponse)(error, 'Failed to check TG balance');
    }
};
exports.checkTgBalance = checkTgBalance;
