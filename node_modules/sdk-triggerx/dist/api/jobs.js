"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toCreateJobDataFromTime = toCreateJobDataFromTime;
exports.toCreateJobDataFromEvent = toCreateJobDataFromEvent;
exports.toCreateJobDataFromCondition = toCreateJobDataFromCondition;
exports.createJob = createJob;
const JobRegistry_1 = require("../contracts/JobRegistry");
const ethers_1 = require("ethers");
const JobRegistry_json_1 = __importDefault(require("../contracts/abi/JobRegistry.json"));
const topupTg_1 = require("./topupTg");
const checkTgBalance_1 = require("./checkTgBalance");
const config_1 = require("../config");
const validation_1 = require("../utils/validation");
const errors_1 = require("../utils/errors");
const SafeWallet_1 = require("../contracts/safe/SafeWallet");
const JOB_ID = '300949528249665590178224313442040528409305273634097553067152835846309150732';
const DYNAMIC_ARGS_URL = 'https://teal-random-koala-993.mypinata.cloud/ipfs/bafkreif426p7t7takzhw3g6we2h6wsvf27p5jxj3gaiynqf22p3jvhx4la';
// Helper function to encode multisend batch transactions
function encodeMultisendData(transactions) {
    // Multisend format: for each transaction, encode as:
    // operation (1 byte) + to (20 bytes) + value (32 bytes) + dataLength (32 bytes) + data (variable)
    let encodedTransactions = '';
    for (const tx of transactions) {
        const txWithOperation = tx;
        const to = txWithOperation.to;
        const value = ethers_1.ethers.toBigInt(txWithOperation.value);
        const data = txWithOperation.data;
        // Remove 0x prefix from data if present
        const dataWithoutPrefix = data.startsWith('0x') ? data.slice(2) : data;
        const dataLength = ethers_1.ethers.toBigInt(dataWithoutPrefix.length / 2);
        // Encode each field and concatenate
        // operation: uint8 (1 byte)
        const operation = typeof txWithOperation.operation === 'number' ? txWithOperation.operation : 0;
        if (operation < 0 || operation > 1) {
            throw new Error(`Invalid Safe transaction operation: ${operation}. Expected 0 (CALL) or 1 (DELEGATECALL).`);
        }
        const operationHex = operation.toString(16).padStart(2, '0');
        // to: address (20 bytes)
        const toHex = to.toLowerCase().replace(/^0x/, '').padStart(40, '0');
        // value: uint256 (32 bytes)
        const valueHex = value.toString(16).padStart(64, '0');
        // dataLength: uint256 (32 bytes)
        const dataLengthHex = dataLength.toString(16).padStart(64, '0');
        // data: bytes (variable length)
        encodedTransactions += operationHex + toHex + valueHex + dataLengthHex + dataWithoutPrefix;
    }
    const packedTransactions = `0x${encodedTransactions}`;
    const multiSendInterface = new ethers_1.ethers.Interface([
        'function multiSend(bytes transactions)'
    ]);
    return multiSendInterface.encodeFunctionData('multiSend', [packedTransactions]);
}
function toCreateJobDataFromTime(input, balances, userAddress, jobCostPrediction) {
    return {
        job_id: JOB_ID,
        user_address: userAddress,
        ether_balance: balances.etherBalance,
        token_balance: balances.tokenBalanceWei,
        job_title: input.jobTitle,
        task_definition_id: input.dynamicArgumentsScriptUrl ? 2 : 1,
        custom: true,
        time_frame: input.timeFrame,
        recurring: false,
        job_cost_prediction: jobCostPrediction,
        timezone: input.timezone,
        created_chain_id: input.chainId,
        schedule_type: input.scheduleType,
        time_interval: input.scheduleType === 'interval' ? input.timeInterval : undefined,
        cron_expression: input.scheduleType === 'cron' ? input.cronExpression : undefined,
        specific_schedule: input.scheduleType === 'specific' ? input.specificSchedule : undefined,
        target_chain_id: input.chainId,
        target_contract_address: input.targetContractAddress || '',
        target_function: input.targetFunction || '',
        abi: input.abi || '',
        arg_type: input.dynamicArgumentsScriptUrl ? 2 : 1,
        arguments: input.arguments,
        dynamic_arguments_script_url: input.dynamicArgumentsScriptUrl,
        is_imua: input.isImua ?? false,
        is_safe: input.walletMode === 'safe',
        safe_name: input.safeName || '',
        safe_address: input.safeAddress || '',
        language: input.language || 'go',
    };
}
function toCreateJobDataFromEvent(input, balances, userAddress, jobCostPrediction) {
    return {
        job_id: JOB_ID,
        user_address: userAddress,
        ether_balance: balances.etherBalance,
        token_balance: balances.tokenBalanceWei,
        job_title: input.jobTitle,
        task_definition_id: input.dynamicArgumentsScriptUrl ? 4 : 3,
        custom: true,
        time_frame: input.timeFrame,
        recurring: input.recurring ?? false,
        job_cost_prediction: jobCostPrediction,
        timezone: input.timezone,
        created_chain_id: input.chainId,
        trigger_chain_id: input.triggerChainId ?? input.chainId,
        trigger_contract_address: input.triggerContractAddress,
        trigger_event: input.triggerEvent,
        target_chain_id: input.chainId,
        target_contract_address: input.targetContractAddress || '',
        target_function: input.targetFunction || '',
        abi: input.abi || '',
        arg_type: input.dynamicArgumentsScriptUrl ? 2 : 1,
        arguments: input.arguments,
        dynamic_arguments_script_url: input.dynamicArgumentsScriptUrl,
        is_imua: input.isImua ?? false,
        is_safe: input.walletMode === 'safe',
        safe_name: input.safeName || '',
        safe_address: input.safeAddress || '',
        language: input.language || 'go',
    };
}
function toCreateJobDataFromCondition(input, balances, userAddress, jobCostPrediction) {
    return {
        job_id: JOB_ID,
        user_address: userAddress,
        ether_balance: balances.etherBalance,
        token_balance: balances.tokenBalanceWei,
        job_title: input.jobTitle,
        task_definition_id: input.dynamicArgumentsScriptUrl ? 6 : 5,
        custom: true,
        time_frame: input.timeFrame,
        recurring: input.recurring ?? false,
        job_cost_prediction: jobCostPrediction,
        timezone: input.timezone,
        created_chain_id: input.chainId,
        condition_type: input.conditionType,
        upper_limit: input.upperLimit,
        lower_limit: input.lowerLimit,
        value_source_type: input.valueSourceType,
        value_source_url: input.valueSourceUrl,
        target_chain_id: input.chainId,
        target_contract_address: input.targetContractAddress || '',
        target_function: input.targetFunction || '',
        abi: input.abi || '',
        arg_type: input.dynamicArgumentsScriptUrl ? 2 : 1,
        arguments: input.arguments,
        dynamic_arguments_script_url: input.dynamicArgumentsScriptUrl,
        is_imua: input.isImua ?? false,
        is_safe: input.walletMode === 'safe',
        safe_name: input.safeName || '',
        safe_address: input.safeAddress || '',
        language: input.language || 'go',
    };
}
// --- Encoding helpers for different job types ---
function encodeJobType1Data(timeInterval) {
    return ethers_1.ethers.AbiCoder.defaultAbiCoder().encode(['uint256'], [timeInterval]);
}
function encodeJobType2Data(timeInterval, ipfsHash) {
    return ethers_1.ethers.AbiCoder.defaultAbiCoder().encode(['uint256', 'bytes32'], [timeInterval, ipfsHash]);
}
function encodeJobType3or5Data(recurringJob) {
    return ethers_1.ethers.AbiCoder.defaultAbiCoder().encode(['bool'], [recurringJob]);
}
function encodeJobType4or6Data(recurringJob, ipfsHash) {
    return ethers_1.ethers.AbiCoder.defaultAbiCoder().encode(['bool', 'bytes32'], [recurringJob, ipfsHash]);
}
/**
 * Create a job on the blockchain.
 * @param client TriggerXClient instance
 * @param params Parameters for creating the job
 * @returns JobResponse containing the result of the job creation
 */
async function createJob(client, params) {
    let { jobInput, signer, encodedData } = params;
    // Use the API key from the client instance
    const apiKey = client.getApiKey();
    if (!apiKey) {
        return (0, errors_1.createErrorResponse)(new errors_1.AuthenticationError('API key is required but not provided'), 'Authentication failed');
    }
    let userAddress;
    try {
        userAddress = await signer.getAddress();
    }
    catch (err) {
        return (0, errors_1.createErrorResponse)(new errors_1.AuthenticationError('Failed to get signer address', { originalError: err }), 'Authentication failed');
    }
    // Resolve chain-specific addresses
    let network;
    try {
        network = await signer.provider?.getNetwork();
    }
    catch (err) {
        return (0, errors_1.createErrorResponse)(new errors_1.NetworkError('Failed to get network information', { originalError: err }), 'Network error');
    }
    const chainIdStr = network?.chainId ? network.chainId.toString() : undefined;
    const { jobRegistry, safeModule, safeFactory, multisendCallOnly } = (0, config_1.getChainAddresses)(chainIdStr);
    const JOB_REGISTRY_ADDRESS = jobRegistry;
    if (!JOB_REGISTRY_ADDRESS) {
        return (0, errors_1.createErrorResponse)(new errors_1.ConfigurationError(`JobRegistry address not configured for chain ID: ${chainIdStr}`), 'Configuration error');
    }
    // If Safe mode, override target fields BEFORE validation so user doesn't need to provide them
    const walletModePre = jobInput.walletMode;
    if (walletModePre === 'safe') {
        if (!safeModule) {
            return (0, errors_1.createErrorResponse)(new errors_1.ConfigurationError('Safe Module address not configured for this chain.'), 'Configuration error');
        }
        // If safeAddress is missing, require it (must be created by the user before this call)
        if (!jobInput.safeAddress || typeof jobInput.safeAddress !== 'string' || !jobInput.safeAddress.trim()) {
            return (0, errors_1.createErrorResponse)(new errors_1.ValidationError('safeAddress', 'safeAddress is required when walletMode is "safe". Call createSafeWallet first.'), 'Validation error');
        }
        // Validate Safe has single owner and owner matches signer
        try {
            await (0, SafeWallet_1.ensureSingleOwnerAndMatchSigner)(jobInput.safeAddress, signer.provider, await signer.getAddress());
            // Ensure module is enabled on Safe
            await (0, SafeWallet_1.enableSafeModule)(jobInput.safeAddress, signer, safeModule);
        }
        catch (err) {
            return (0, errors_1.createErrorResponse)(new errors_1.ContractError('Failed to configure Safe wallet', { originalError: err, safeAddress: jobInput.safeAddress }), 'Contract error');
        }
        // Auto-set module target; user does not need to pass targetContractAddress in safe mode
        jobInput.targetContractAddress = safeModule;
        // Function signature must match exactly as in ABI
        jobInput.targetFunction = 'execJobFromHub';
        // ABI verified per provided interface and matches execJobFromHub
        jobInput.abi = JSON.stringify([
            {
                "inputs": [
                    { "internalType": "address", "name": "safeAddress", "type": "address" },
                    { "internalType": "address", "name": "actionTarget", "type": "address" },
                    { "internalType": "uint256", "name": "actionValue", "type": "uint256" },
                    { "internalType": "bytes", "name": "actionData", "type": "bytes" },
                    { "internalType": "uint8", "name": "operation", "type": "uint8" }
                ],
                "name": "execJobFromHub",
                "outputs": [
                    { "internalType": "bool", "name": "success", "type": "bool" }
                ],
                "stateMutability": "nonpayable",
                "type": "function"
            }
        ]);
        // Handle static vs dynamic safe wallet jobs
        const hasDynamicUrl = !!jobInput.dynamicArgumentsScriptUrl;
        const hasSafeTransactions = !!(jobInput.safeTransactions && jobInput.safeTransactions.length > 0);
        if (hasDynamicUrl) {
            // Dynamic safe wallet job - keep existing behavior
            jobInput.arguments = undefined;
        }
        else if (hasSafeTransactions) {
            // Static safe wallet job - encode transactions into arguments
            const safeTransactions = jobInput.safeTransactions;
            const safeAddress = jobInput.safeAddress;
            if (safeTransactions.length === 1) {
                // Single transaction: use transaction directly
                const tx = safeTransactions[0];
                jobInput.arguments = [
                    safeAddress,
                    tx.to,
                    tx.value,
                    tx.data,
                    '0' // CALL
                ];
            }
            else {
                // Multiple transactions: use multisend
                if (!multisendCallOnly) {
                    return (0, errors_1.createErrorResponse)(new errors_1.ConfigurationError('MultisendCallOnly address not configured for this chain.'), 'Configuration error');
                }
                const encodedMultisendData = encodeMultisendData(safeTransactions);
                jobInput.arguments = [
                    safeAddress,
                    multisendCallOnly,
                    '0',
                    encodedMultisendData,
                    '1' // DELEGATECALL
                ];
            }
        }
        else {
            // Will be caught by validation
            jobInput.arguments = undefined;
        }
    }
    // 0. Validate user input thoroughly before proceeding (after safe overrides)
    try {
        const argValue = jobInput.argType;
        (0, validation_1.validateJobInput)(jobInput, argValue);
        console.log('Job input validated successfully');
    }
    catch (err) {
        if (err instanceof errors_1.ValidationError) {
            return (0, errors_1.createErrorResponse)(err);
        }
        return (0, errors_1.createErrorResponse)(err, 'Job input validation failed');
    }
    let jobTitle = '';
    let timeFrame = 0;
    let targetContractAddress = '';
    let jobType = 0;
    if ('jobTitle' in jobInput)
        jobTitle = jobInput.jobTitle;
    if ('timeFrame' in jobInput)
        timeFrame = jobInput.timeFrame;
    if ('targetContractAddress' in jobInput)
        targetContractAddress = jobInput.targetContractAddress || '';
    // Validate schedule-specific fields for time-based jobs
    if ('scheduleType' in jobInput) {
        if (jobInput.scheduleType === 'interval' && (jobInput.timeInterval === undefined || jobInput.timeInterval === null)) {
            return (0, errors_1.createErrorResponse)(new errors_1.ValidationError('timeInterval', 'timeInterval is required when scheduleType is interval'), 'Validation error');
        }
        if (jobInput.scheduleType === 'cron' && !jobInput.cronExpression) {
            return (0, errors_1.createErrorResponse)(new errors_1.ValidationError('cronExpression', 'cronExpression is required when scheduleType is cron'), 'Validation error');
        }
        if (jobInput.scheduleType === 'specific' && !jobInput.specificSchedule) {
            return (0, errors_1.createErrorResponse)(new errors_1.ValidationError('specificSchedule', 'specificSchedule is required when scheduleType is specific'), 'Validation error');
        }
    }
    // Infer jobType from jobInput
    if ('scheduleType' in jobInput) {
        jobType = jobInput.dynamicArgumentsScriptUrl ? 2 : 1; // Time-based job
    }
    else if ('triggerChainId' in jobInput) {
        jobType = jobInput.dynamicArgumentsScriptUrl ? 4 : 3; // Event-based job
    }
    else {
        jobType = jobInput.dynamicArgumentsScriptUrl ? 6 : 5; // Condition-based job
    }
    // --- Generate encodedData if not provided ---
    if (!encodedData) {
        // Time-based jobs
        if ('scheduleType' in jobInput) {
            if (jobType === 1) {
                encodedData = encodeJobType1Data(jobInput.timeInterval ?? 0);
            }
            else if (jobType === 2) {
                const ipfsBytes32 = jobInput.dynamicArgumentsScriptUrl ? ethers_1.ethers.id(jobInput.dynamicArgumentsScriptUrl) : ethers_1.ethers.ZeroHash;
                encodedData = encodeJobType2Data(jobInput.timeInterval ?? 0, ipfsBytes32);
            }
        }
        // Event-based jobs
        else if ('triggerChainId' in jobInput) {
            if (jobType === 3 || jobType === 5) {
                encodedData = encodeJobType3or5Data(jobInput.recurring ?? false);
            }
            else if (jobType === 4 || jobType === 6) {
                const ipfsBytes32 = jobInput.dynamicArgumentsScriptUrl ? ethers_1.ethers.id(jobInput.dynamicArgumentsScriptUrl) : ethers_1.ethers.ZeroHash;
                encodedData = encodeJobType4or6Data(jobInput.recurring ?? false, ipfsBytes32);
            }
        }
        // Condition-based jobs
        else {
            if (jobType === 3 || jobType === 5) {
                encodedData = encodeJobType3or5Data(jobInput.recurring ?? false);
            }
            else if (jobType === 4 || jobType === 6) {
                const ipfsBytes32 = jobInput.dynamicArgumentsScriptUrl ? ethers_1.ethers.id(jobInput.dynamicArgumentsScriptUrl) : ethers_1.ethers.ZeroHash;
                encodedData = encodeJobType4or6Data(jobInput.recurring ?? false, ipfsBytes32);
            }
        }
    }
    // Handle job_cost_prediction logic based on argType (static/dynamic)
    // If static, set to 0.1. If dynamic, call backend API to get fee and ask user to proceed.
    // Determine argType directly from user input
    let argType = 1; // default to static
    if ('argType' in jobInput) {
        if (jobInput.argType === 'dynamic' || jobInput.argType === 2) {
            argType = 2;
        }
        else {
            argType = 1;
        }
    }
    //if jobis time based then check the no of executions of the job from time frame and time interval by deviding time frame by time interval
    let noOfExecutions = 1;
    if ('scheduleType' in jobInput) {
        noOfExecutions = jobInput.timeFrame / (jobInput.timeInterval ?? 0);
    }
    // Set job_cost_prediction
    let job_cost_prediction = 0.1 * noOfExecutions; // default for static
    if (argType === 2) {
        // Dynamic: call backend API to get fee
        const ipfs_url = jobInput.dynamicArgumentsScriptUrl;
        if (!ipfs_url) {
            return (0, errors_1.createErrorResponse)(new errors_1.ValidationError('dynamicArgumentsScriptUrl', 'dynamicArgumentsScriptUrl is required for dynamic argType'), 'Validation error');
        }
        // Call backend API to get fee
        let fee = 0;
        try {
            const feeRes = await client.get('/api/fees', { params: { ipfs_url } });
            // The API now returns { total_fee: number }
            if (feeRes && typeof feeRes.total_fee === 'number') {
                fee = feeRes.total_fee;
            }
            else if (feeRes && feeRes.data && typeof feeRes.data.total_fee === 'number') {
                fee = feeRes.data.total_fee;
            }
            else {
                return (0, errors_1.createErrorResponse)(new errors_1.ApiError('Invalid response from /api/fees: missing total_fee', { response: feeRes }), 'API error');
            }
        }
        catch (err) {
            const httpStatusCode = (0, errors_1.extractHttpStatusCode)(err);
            const errorCode = (0, errors_1.determineErrorCode)(err, httpStatusCode);
            return (0, errors_1.createErrorResponse)(new errors_1.ApiError('Failed to fetch job cost prediction', { originalError: err, ipfs_url }, httpStatusCode), 'API error');
        }
        job_cost_prediction = fee * noOfExecutions;
    }
    // Ask user if they want to proceed
    // Since this is a library, we can't prompt in Node.js directly.
    // We'll throw an error with the fee and let the caller handle the prompt/confirmation.
    // If you want to automate, you can add a `proceed` flag to params in the future.
    // Check if the user has enough TG to cover the job cost prediction
    let tgBalanceWei, tgBalance;
    try {
        const balanceResult = await (0, checkTgBalance_1.checkTgBalance)(signer);
        if (!balanceResult.success || !balanceResult.data) {
            return (0, errors_1.createErrorResponse)(new errors_1.BalanceError('Failed to check TG balance', balanceResult.details), 'Balance check error');
        }
        tgBalanceWei = balanceResult.data.tgBalanceWei;
        tgBalance = balanceResult.data.tgBalance;
    }
    catch (err) {
        return (0, errors_1.createErrorResponse)(new errors_1.BalanceError('Failed to check TG balance', { originalError: err }), 'Balance check error');
    }
    if (Number(tgBalance) < job_cost_prediction) {
        // Check if user has enabled auto topup
        // For each job type, autotopupTG should be present in jobInput
        const autoTopupTG = jobInput.autotopupTG === true;
        if (!autoTopupTG) {
            return (0, errors_1.createErrorResponse)(new errors_1.BalanceError(`Insufficient TG balance. Job cost prediction is ${job_cost_prediction}. Current TG balance: ${tgBalance}. Please set autotopupTG: true in jobInput.`, {
                required: job_cost_prediction,
                current: tgBalance,
                autoTopupEnabled: false
            }), 'Insufficient balance');
        }
        else {
            // autotopupTG is true, automatically top up
            const requiredTG = Math.ceil(job_cost_prediction); // 1 TG = 0.001 ETH
            try {
                const topupResult = await (0, topupTg_1.topupTg)(requiredTG, signer);
                if (!topupResult.success) {
                    return (0, errors_1.createErrorResponse)(new errors_1.BalanceError('Failed to top up TG balance', topupResult.details), 'Top-up error');
                }
            }
            catch (err) {
                return (0, errors_1.createErrorResponse)(new errors_1.BalanceError('Failed to top up TG balance', { originalError: err, requiredTG }), 'Top-up error');
            }
        }
    }
    // Compute balances to store with the job
    const tokenBalanceWei = tgBalanceWei;
    const etherBalance = tokenBalanceWei / 1000n;
    // Patch jobInput with job_cost_prediction for downstream usage
    jobInput.jobCostPrediction = job_cost_prediction;
    let jobId;
    try {
        jobId = await (0, JobRegistry_1.createJobOnChain)({
            jobTitle: jobTitle,
            jobType,
            timeFrame: timeFrame,
            targetContractAddress: targetContractAddress,
            encodedData: encodedData || '',
            contractAddress: JOB_REGISTRY_ADDRESS,
            abi: JobRegistry_json_1.default.abi,
            signer,
        });
    }
    catch (err) {
        return (0, errors_1.createErrorResponse)(new errors_1.ContractError('Failed to create job on chain', { originalError: err, jobTitle, jobType, timeFrame }), 'Contract error');
    }
    // 2. Convert input to CreateJobData
    let jobData;
    const balances = { etherBalance, tokenBalanceWei };
    if ('scheduleType' in jobInput) {
        jobData = toCreateJobDataFromTime(jobInput, balances, userAddress, job_cost_prediction);
    }
    else if ('triggerChainId' in jobInput) {
        jobData = toCreateJobDataFromEvent(jobInput, balances, userAddress, job_cost_prediction);
    }
    else {
        jobData = toCreateJobDataFromCondition(jobInput, balances, userAddress, job_cost_prediction);
    }
    // 3. Set the job_id from contract
    jobData.job_id = jobId;
    // 4. Call the API
    try {
        // Ensure JSON-serializable payload (use numbers for balances)
        const jobDataForApi = {
            ...jobData,
            ether_balance: typeof jobData.ether_balance === 'bigint' ? Number(jobData.ether_balance) : Number(jobData.ether_balance),
            token_balance: typeof jobData.token_balance === 'bigint' ? Number(jobData.token_balance) : Number(jobData.token_balance),
        };
        console.log('jobDataForApi', jobDataForApi);
        const res = await client.post('/api/jobs', [jobDataForApi], {
            headers: { 'Content-Type': 'application/json', 'X-API-KEY': apiKey },
        });
        return { success: true, data: res };
    }
    catch (error) {
        const httpStatusCode = (0, errors_1.extractHttpStatusCode)(error);
        const errorCode = (0, errors_1.determineErrorCode)(error, httpStatusCode);
        return (0, errors_1.createErrorResponse)(new errors_1.ApiError('Failed to create job via API', { originalError: error, jobId }, httpStatusCode), 'API error');
    }
}
