"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.topupTg = void 0;
const ethers_1 = require("ethers");
const GasRegistry_json_1 = __importDefault(require("../contracts/abi/GasRegistry.json"));
const config_1 = require("../config");
const errors_1 = require("../utils/errors");
const topupTg = async (tgAmount, signer) => {
    // Validate inputs
    if (!tgAmount || tgAmount <= 0) {
        return (0, errors_1.createErrorResponse)(new errors_1.ValidationError('tgAmount', 'TG amount must be a positive number'), 'Validation error');
    }
    if (!signer) {
        return (0, errors_1.createErrorResponse)(new errors_1.ValidationError('signer', 'Signer is required'), 'Validation error');
    }
    try {
        const network = await signer.provider?.getNetwork();
        const chainId = network?.chainId ? network.chainId.toString() : undefined;
        const { gasRegistry } = (0, config_1.getChainAddresses)(chainId);
        const gasRegistryContractAddress = gasRegistry;
        if (!gasRegistryContractAddress) {
            return (0, errors_1.createErrorResponse)(new errors_1.ConfigurationError(`GasRegistry address not configured for chain ID: ${chainId}`), 'Configuration error');
        }
        const contract = new ethers_1.ethers.Contract(gasRegistryContractAddress, GasRegistry_json_1.default, signer);
        // Each TG costs 0.001 ETH, so calculate the ETH required for the given TG amount
        const amountInEthWei = tgAmount;
        // const amountInEthWei = ethers.parseEther(amountInEth.toString());
        const tx = await contract.purchaseTG(amountInEthWei, { value: amountInEthWei });
        await tx.wait();
        return { success: true, data: tx };
    }
    catch (error) {
        console.error('Error topping up TG:', error);
        if (error instanceof Error) {
            if (error.message.includes('network') || error.message.includes('timeout')) {
                return (0, errors_1.createErrorResponse)(new errors_1.NetworkError('Network error during TG top-up', { originalError: error, tgAmount }), 'Network error');
            }
            else if (error.message.includes('contract') || error.message.includes('transaction')) {
                return (0, errors_1.createErrorResponse)(new errors_1.ContractError('Contract error during TG top-up', { originalError: error, tgAmount }), 'Contract error');
            }
            else if (error.message.includes('insufficient funds') || error.message.includes('balance')) {
                return (0, errors_1.createErrorResponse)(new errors_1.ValidationError('balance', 'Insufficient funds for TG top-up', { originalError: error, tgAmount }), 'Validation error');
            }
        }
        return (0, errors_1.createErrorResponse)(error, 'Failed to top up TG');
    }
};
exports.topupTg = topupTg;
