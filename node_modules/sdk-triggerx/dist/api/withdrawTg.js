"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.withdrawTg = void 0;
const ethers_1 = require("ethers");
const GasRegistry_json_1 = __importDefault(require("../contracts/abi/GasRegistry.json"));
const config_1 = require("../config");
const errors_1 = require("../utils/errors");
/**
 * Withdraw ETH in exchange for TG tokens.
 * @param signer ethers.Signer instance
 * @param amountTG The amount of TG tokens to withdraw (as a string or BigNumberish)
 * @returns The transaction object or error response
 */
const withdrawTg = async (signer, amountTG) => {
    // Validate inputs
    if (!signer) {
        return (0, errors_1.createErrorResponse)(new errors_1.ValidationError('signer', 'Signer is required'), 'Validation error');
    }
    if (!amountTG || (typeof amountTG === 'string' && amountTG.trim() === '') || Number(amountTG) <= 0) {
        return (0, errors_1.createErrorResponse)(new errors_1.ValidationError('amountTG', 'Amount must be a positive number'), 'Validation error');
    }
    try {
        const network = await signer.provider?.getNetwork();
        const chainId = network?.chainId ? network.chainId.toString() : undefined;
        const { gasRegistry } = (0, config_1.getChainAddresses)(chainId);
        const gasRegistryContractAddress = gasRegistry;
        if (!gasRegistryContractAddress) {
            return (0, errors_1.createErrorResponse)(new errors_1.ConfigurationError(`GasRegistry address not configured for chain ID: ${chainId}`), 'Configuration error');
        }
        const contract = new ethers_1.ethers.Contract(gasRegistryContractAddress, GasRegistry_json_1.default, signer);
        // Assumes the contract has a function: claimEthForTg(uint256 amount)
        const amountTGWei = ethers_1.ethers.parseEther(amountTG.toString());
        const tx = await contract.claimETHForTG(amountTGWei);
        await tx.wait();
        return { success: true, data: tx };
    }
    catch (error) {
        console.error('Error withdrawing TG:', error);
        if (error instanceof Error) {
            if (error.message.includes('network') || error.message.includes('timeout')) {
                return (0, errors_1.createErrorResponse)(new errors_1.NetworkError('Network error during TG withdrawal', { originalError: error, amountTG }), 'Network error');
            }
            else if (error.message.includes('contract') || error.message.includes('transaction')) {
                return (0, errors_1.createErrorResponse)(new errors_1.ContractError('Contract error during TG withdrawal', { originalError: error, amountTG }), 'Contract error');
            }
            else if (error.message.includes('insufficient') || error.message.includes('balance')) {
                return (0, errors_1.createErrorResponse)(new errors_1.ValidationError('balance', 'Insufficient TG balance for withdrawal', { originalError: error, amountTG }), 'Validation error');
            }
        }
        return (0, errors_1.createErrorResponse)(error, 'Failed to withdraw TG');
    }
};
exports.withdrawTg = withdrawTg;
