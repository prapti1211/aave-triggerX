"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateTimeBasedJobInput = validateTimeBasedJobInput;
exports.validateEventBasedJobInput = validateEventBasedJobInput;
exports.validateConditionBasedJobInput = validateConditionBasedJobInput;
exports.validateJobInput = validateJobInput;
const ethers_1 = require("ethers");
const errors_1 = require("./errors");
function isNonEmptyString(value) {
    return typeof value === 'string' && value.trim().length > 0;
}
function isValidUrl(value) {
    try {
        // eslint-disable-next-line no-new
        new URL(value);
        return true;
    }
    catch {
        return false;
    }
}
function buildFunctionSignature(name, inputs) {
    const types = (inputs || []).map((i) => i.type).join(',');
    return `${name}(${types})`;
}
function parseAbi(abiString) {
    if (!isNonEmptyString(abiString))
        return null;
    try {
        const parsed = JSON.parse(abiString);
        return Array.isArray(parsed) ? parsed : null;
    }
    catch {
        return null;
    }
}
function validateContractBasics(address, abi, targetFunction, fieldPrefix = 'contract') {
    if (!isNonEmptyString(address)) {
        throw new errors_1.ValidationError(`${fieldPrefix}Address`, 'Contract address is required.');
    }
    if (!ethers_1.ethers.isAddress(address)) {
        throw new errors_1.ValidationError(`${fieldPrefix}Address`, 'Invalid contract address.');
    }
    if (!isNonEmptyString(abi)) {
        throw new errors_1.ValidationError(`${fieldPrefix}ABI`, 'Contract ABI must be provided.');
    }
    if (!isNonEmptyString(targetFunction)) {
        throw new errors_1.ValidationError(`${fieldPrefix}Target`, 'Target function must be selected.');
    }
}
function validateStaticArguments(abiString, targetFunction, args, fieldPrefix = 'contract') {
    const abi = parseAbi(abiString);
    if (!abi) {
        // If ABI is invalid JSON, surface a clear error
        throw new errors_1.ValidationError(`${fieldPrefix}ABI`, 'Contract ABI must be valid JSON array.');
    }
    const fnItem = abi.find((item) => item && item.type === 'function' && buildFunctionSignature(item.name, item.inputs) === targetFunction);
    if (!fnItem)
        return; // If we cannot find it, skip strict arg validation
    const inputs = Array.isArray(fnItem.inputs) ? fnItem.inputs : [];
    if (inputs.length === 0)
        return;
    if (!args || args.length < inputs.length) {
        throw new errors_1.ValidationError(`${fieldPrefix}Args`, 'All function arguments are required for static argument type.');
    }
    const missing = inputs.findIndex((_, idx) => !isNonEmptyString(args[idx]));
    if (missing !== -1) {
        throw new errors_1.ValidationError(`${fieldPrefix}Args`, 'All function arguments are required for static argument type.');
    }
}
function validateSafeTransactions(transactions) {
    if (!transactions || !Array.isArray(transactions) || transactions.length === 0) {
        throw new errors_1.ValidationError('safeTransactions', 'safeTransactions array is required and must contain at least one transaction for static safe wallet jobs.');
    }
    for (let i = 0; i < transactions.length; i++) {
        const tx = transactions[i];
        if (!tx || typeof tx !== 'object') {
            throw new errors_1.ValidationError('safeTransactions', `Transaction at index ${i} is invalid.`);
        }
        if (!isNonEmptyString(tx.to) || !ethers_1.ethers.isAddress(tx.to)) {
            throw new errors_1.ValidationError('safeTransactions', `Transaction at index ${i}: 'to' must be a valid Ethereum address.`);
        }
        if (typeof tx.value !== 'string') {
            throw new errors_1.ValidationError('safeTransactions', `Transaction at index ${i}: 'value' must be a string representing wei amount.`);
        }
        if (!isNonEmptyString(tx.data) || !tx.data.startsWith('0x')) {
            throw new errors_1.ValidationError('safeTransactions', `Transaction at index ${i}: 'data' must be a hex string starting with 0x.`);
        }
    }
}
function validateTimeBasedJobInput(input, argType) {
    if (!isNonEmptyString(input.jobTitle)) {
        throw new errors_1.ValidationError('jobTitle', 'Job title is required.');
    }
    if (!input.timeFrame || input.timeFrame <= 0) {
        throw new errors_1.ValidationError('timeframe', 'Timeframe must be a positive number of seconds.');
    }
    if (!isNonEmptyString(input.timezone)) {
        throw new errors_1.ValidationError('timezone', 'Timezone is required.');
    }
    if (!isNonEmptyString(input.chainId)) {
        throw new errors_1.ValidationError('chainId', 'Chain ID is required.');
    }
    // Schedule-specific required fields
    if (input.scheduleType === 'interval') {
        if (input.timeInterval === undefined || input.timeInterval === null || input.timeInterval <= 0) {
            throw new errors_1.ValidationError('timeInterval', 'timeInterval is required and must be > 0 when scheduleType is interval.');
        }
        if (input.timeInterval > input.timeFrame) {
            throw new errors_1.ValidationError('timeInterval', 'Time interval cannot exceed the timeframe.');
        }
    }
    else if (input.scheduleType === 'cron') {
        if (!isNonEmptyString(input.cronExpression)) {
            throw new errors_1.ValidationError('cronExpression', 'cronExpression is required when scheduleType is cron.');
        }
    }
    else if (input.scheduleType === 'specific') {
        if (!isNonEmptyString(input.specificSchedule)) {
            throw new errors_1.ValidationError('specificSchedule', 'specificSchedule is required when scheduleType is specific.');
        }
    }
    else {
        throw new errors_1.ValidationError('scheduleType', 'scheduleType must be one of interval | cron | specific.');
    }
    // Arg type checks
    const isDynamic = argType === 'dynamic' || argType === 2;
    // Safe wallet mode validation
    if (input.walletMode === 'safe') {
        // Ensure static and dynamic are mutually exclusive
        if (isDynamic && input.safeTransactions && input.safeTransactions.length > 0) {
            throw new errors_1.ValidationError('safeTransactions', 'Cannot provide both dynamicArgumentsScriptUrl and safeTransactions. Use one or the other.');
        }
        if (!isDynamic && !input.safeTransactions) {
            throw new errors_1.ValidationError('safeTransactions', 'For static safe wallet jobs, either provide safeTransactions or use dynamicArgumentsScriptUrl for dynamic jobs.');
        }
        if (isDynamic) {
            // Dynamic safe wallet job
            if (!isNonEmptyString(input.dynamicArgumentsScriptUrl) || !isValidUrl(input.dynamicArgumentsScriptUrl)) {
                throw new errors_1.ValidationError('contractIpfs', 'IPFS Code URL is required and must be valid for dynamic argument type.');
            }
        }
        else {
            // Static safe wallet job
            validateSafeTransactions(input.safeTransactions);
        }
    }
    else {
        // Regular wallet mode
        validateContractBasics(input.targetContractAddress, input.abi, input.targetFunction, 'contract');
        if (isDynamic) {
            if (!isNonEmptyString(input.dynamicArgumentsScriptUrl) || !isValidUrl(input.dynamicArgumentsScriptUrl)) {
                throw new errors_1.ValidationError('contractIpfs', 'IPFS Code URL is required and must be valid for dynamic argument type.');
            }
        }
        else {
            validateStaticArguments(input.abi, input.targetFunction, input.arguments, 'contract');
        }
    }
}
function validateEventBasedJobInput(input, argType) {
    if (!isNonEmptyString(input.jobTitle)) {
        throw new errors_1.ValidationError('jobTitle', 'Job title is required.');
    }
    if (!input.timeFrame || input.timeFrame <= 0) {
        throw new errors_1.ValidationError('timeframe', 'Timeframe must be a positive number of seconds.');
    }
    if (!isNonEmptyString(input.timezone)) {
        throw new errors_1.ValidationError('timezone', 'Timezone is required.');
    }
    if (!isNonEmptyString(input.chainId)) {
        throw new errors_1.ValidationError('chainId', 'Chain ID is required.');
    }
    if (!isNonEmptyString(input.triggerChainId)) {
        throw new errors_1.ValidationError('triggerChainId', 'Trigger chain ID is required.');
    }
    validateContractBasics(input.triggerContractAddress, input.abi, input.triggerEvent, 'eventContract');
    // Arg type checks
    const isDynamic = argType === 'dynamic' || argType === 2;
    // Safe wallet mode validation
    if (input.walletMode === 'safe') {
        // Ensure static and dynamic are mutually exclusive
        if (isDynamic && input.safeTransactions && input.safeTransactions.length > 0) {
            throw new errors_1.ValidationError('safeTransactions', 'Cannot provide both dynamicArgumentsScriptUrl and safeTransactions. Use one or the other.');
        }
        if (!isDynamic && !input.safeTransactions) {
            throw new errors_1.ValidationError('safeTransactions', 'For static safe wallet jobs, either provide safeTransactions or use dynamicArgumentsScriptUrl for dynamic jobs.');
        }
        if (isDynamic) {
            // Dynamic safe wallet job
            if (!isNonEmptyString(input.dynamicArgumentsScriptUrl) || !isValidUrl(input.dynamicArgumentsScriptUrl)) {
                throw new errors_1.ValidationError('contractIpfs', 'IPFS Code URL is required and must be valid for dynamic argument type.');
            }
        }
        else {
            // Static safe wallet job
            validateSafeTransactions(input.safeTransactions);
        }
    }
    else {
        // Regular wallet mode
        validateContractBasics(input.targetContractAddress, input.abi, input.targetFunction, 'contract');
        if (isDynamic) {
            if (!isNonEmptyString(input.dynamicArgumentsScriptUrl) || !isValidUrl(input.dynamicArgumentsScriptUrl)) {
                throw new errors_1.ValidationError('contractIpfs', 'IPFS Code URL is required and must be valid for dynamic argument type.');
            }
        }
        else {
            validateStaticArguments(input.abi, input.targetFunction, input.arguments, 'contract');
        }
    }
}
function validateConditionBasedJobInput(input, argType) {
    if (!isNonEmptyString(input.jobTitle)) {
        throw new errors_1.ValidationError('jobTitle', 'Job title is required.');
    }
    if (!input.timeFrame || input.timeFrame <= 0) {
        throw new errors_1.ValidationError('timeframe', 'Timeframe must be a positive number of seconds.');
    }
    if (!isNonEmptyString(input.timezone)) {
        throw new errors_1.ValidationError('timezone', 'Timezone is required.');
    }
    if (!isNonEmptyString(input.chainId)) {
        throw new errors_1.ValidationError('chainId', 'Chain ID is required.');
    }
    // Condition fields
    if (!isNonEmptyString(input.conditionType)) {
        throw new errors_1.ValidationError('contractConditionType', 'Condition type is required.');
    }
    if (!isNonEmptyString(input.valueSourceType)) {
        throw new errors_1.ValidationError('contractSourceType', 'Value source type is required.');
    }
    if (!isNonEmptyString(input.valueSourceUrl) || !isValidUrl(input.valueSourceUrl)) {
        throw new errors_1.ValidationError('contractSourceUrl', 'Source URL is required and must be valid.');
    }
    if (input.conditionType === 'between') {
        if (input.upperLimit === undefined || input.lowerLimit === undefined || input.upperLimit === null || input.lowerLimit === null) {
            throw new errors_1.ValidationError('contractLimits', 'Both upper and lower limits are required.');
        }
    }
    else {
        if (input.upperLimit === undefined || input.upperLimit === null) {
            throw new errors_1.ValidationError('contractLimits', 'Value is required.');
        }
    }
    // Arg type checks
    const isDynamic = argType === 'dynamic' || argType === 2;
    // Safe wallet mode validation
    if (input.walletMode === 'safe') {
        // Ensure static and dynamic are mutually exclusive
        if (isDynamic && input.safeTransactions && input.safeTransactions.length > 0) {
            throw new errors_1.ValidationError('safeTransactions', 'Cannot provide both dynamicArgumentsScriptUrl and safeTransactions. Use one or the other.');
        }
        if (!isDynamic && !input.safeTransactions) {
            throw new errors_1.ValidationError('safeTransactions', 'For static safe wallet jobs, either provide safeTransactions or use dynamicArgumentsScriptUrl for dynamic jobs.');
        }
        if (isDynamic) {
            // Dynamic safe wallet job
            if (!isNonEmptyString(input.dynamicArgumentsScriptUrl) || !isValidUrl(input.dynamicArgumentsScriptUrl)) {
                throw new errors_1.ValidationError('contractIpfs', 'IPFS Code URL is required and must be valid for dynamic argument type.');
            }
        }
        else {
            // Static safe wallet job
            validateSafeTransactions(input.safeTransactions);
        }
    }
    else {
        // Regular wallet mode
        validateContractBasics(input.targetContractAddress, input.abi, input.targetFunction, 'contract');
        if (isDynamic) {
            if (!isNonEmptyString(input.dynamicArgumentsScriptUrl) || !isValidUrl(input.dynamicArgumentsScriptUrl)) {
                throw new errors_1.ValidationError('contractIpfs', 'IPFS Code URL is required and must be valid for dynamic argument type.');
            }
        }
        else {
            validateStaticArguments(input.abi, input.targetFunction, input.arguments, 'contract');
        }
    }
}
function validateJobInput(jobInput, argType) {
    if ('scheduleType' in jobInput) {
        validateTimeBasedJobInput(jobInput, argType);
    }
    else if ('triggerChainId' in jobInput) {
        validateEventBasedJobInput(jobInput, argType);
    }
    else {
        validateConditionBasedJobInput(jobInput, argType);
    }
}
