"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateTimeBasedJobInput = validateTimeBasedJobInput;
exports.validateEventBasedJobInput = validateEventBasedJobInput;
exports.validateConditionBasedJobInput = validateConditionBasedJobInput;
exports.validateJobInput = validateJobInput;
const ethers_1 = require("ethers");
const errors_1 = require("./errors");
function isNonEmptyString(value) {
    return typeof value === 'string' && value.trim().length > 0;
}
function isValidUrl(value) {
    try {
        // eslint-disable-next-line no-new
        new URL(value);
        return true;
    }
    catch {
        return false;
    }
}
function buildFunctionSignature(name, inputs) {
    const types = (inputs || []).map((i) => i.type).join(',');
    return `${name}(${types})`;
}
function parseAbi(abiString) {
    if (!isNonEmptyString(abiString))
        return null;
    try {
        const parsed = JSON.parse(abiString);
        return Array.isArray(parsed) ? parsed : null;
    }
    catch {
        return null;
    }
}
function validateContractBasics(address, abi, targetFunction, fieldPrefix = 'contract') {
    if (!isNonEmptyString(address)) {
        throw new errors_1.ValidationError(`${fieldPrefix}Address`, 'Contract address is required.');
    }
    if (!ethers_1.ethers.isAddress(address)) {
        throw new errors_1.ValidationError(`${fieldPrefix}Address`, 'Invalid contract address.');
    }
    if (!isNonEmptyString(abi)) {
        throw new errors_1.ValidationError(`${fieldPrefix}ABI`, 'Contract ABI must be provided.');
    }
    if (!isNonEmptyString(targetFunction)) {
        throw new errors_1.ValidationError(`${fieldPrefix}Target`, 'Target function must be selected.');
    }
}
function validateStaticArguments(abiString, targetFunction, args, fieldPrefix = 'contract') {
    const abi = parseAbi(abiString);
    if (!abi) {
        // If ABI is invalid JSON, surface a clear error
        throw new errors_1.ValidationError(`${fieldPrefix}ABI`, 'Contract ABI must be valid JSON array.');
    }
    const fnItem = abi.find((item) => item && item.type === 'function' && buildFunctionSignature(item.name, item.inputs) === targetFunction);
    if (!fnItem)
        return; // If we cannot find it, skip strict arg validation
    const inputs = Array.isArray(fnItem.inputs) ? fnItem.inputs : [];
    if (inputs.length === 0)
        return;
    if (!args || args.length < inputs.length) {
        throw new errors_1.ValidationError(`${fieldPrefix}Args`, 'All function arguments are required for static argument type.');
    }
    const missing = inputs.findIndex((_, idx) => !isNonEmptyString(args[idx]));
    if (missing !== -1) {
        throw new errors_1.ValidationError(`${fieldPrefix}Args`, 'All function arguments are required for static argument type.');
    }
}
function validateTimeBasedJobInput(input, argType) {
    if (!isNonEmptyString(input.jobTitle)) {
        throw new errors_1.ValidationError('jobTitle', 'Job title is required.');
    }
    if (!input.timeFrame || input.timeFrame <= 0) {
        throw new errors_1.ValidationError('timeframe', 'Timeframe must be a positive number of seconds.');
    }
    if (!isNonEmptyString(input.timezone)) {
        throw new errors_1.ValidationError('timezone', 'Timezone is required.');
    }
    if (!isNonEmptyString(input.chainId)) {
        throw new errors_1.ValidationError('chainId', 'Chain ID is required.');
    }
    // Schedule-specific required fields
    if (input.scheduleType === 'interval') {
        if (input.timeInterval === undefined || input.timeInterval === null || input.timeInterval <= 0) {
            throw new errors_1.ValidationError('timeInterval', 'timeInterval is required and must be > 0 when scheduleType is interval.');
        }
        if (input.timeInterval > input.timeFrame) {
            throw new errors_1.ValidationError('timeInterval', 'Time interval cannot exceed the timeframe.');
        }
    }
    else if (input.scheduleType === 'cron') {
        if (!isNonEmptyString(input.cronExpression)) {
            throw new errors_1.ValidationError('cronExpression', 'cronExpression is required when scheduleType is cron.');
        }
    }
    else if (input.scheduleType === 'specific') {
        if (!isNonEmptyString(input.specificSchedule)) {
            throw new errors_1.ValidationError('specificSchedule', 'specificSchedule is required when scheduleType is specific.');
        }
    }
    else {
        throw new errors_1.ValidationError('scheduleType', 'scheduleType must be one of interval | cron | specific.');
    }
    if (input.walletMode !== 'safe') {
        validateContractBasics(input.targetContractAddress, input.abi, input.targetFunction, 'contract');
    }
    // Arg type checks
    const isDynamic = argType === 'dynamic' || argType === 2;
    if (isDynamic) {
        if (!isNonEmptyString(input.dynamicArgumentsScriptUrl) || !isValidUrl(input.dynamicArgumentsScriptUrl)) {
            throw new errors_1.ValidationError('contractIpfs', 'IPFS Code URL is required and must be valid for dynamic argument type.');
        }
    }
    else {
        if (input.walletMode !== 'safe') {
            validateStaticArguments(input.abi, input.targetFunction, input.arguments, 'contract');
        }
    }
}
function validateEventBasedJobInput(input, argType) {
    if (!isNonEmptyString(input.jobTitle)) {
        throw new errors_1.ValidationError('jobTitle', 'Job title is required.');
    }
    if (!input.timeFrame || input.timeFrame <= 0) {
        throw new errors_1.ValidationError('timeframe', 'Timeframe must be a positive number of seconds.');
    }
    if (!isNonEmptyString(input.timezone)) {
        throw new errors_1.ValidationError('timezone', 'Timezone is required.');
    }
    if (!isNonEmptyString(input.chainId)) {
        throw new errors_1.ValidationError('chainId', 'Chain ID is required.');
    }
    if (!isNonEmptyString(input.triggerChainId)) {
        throw new errors_1.ValidationError('triggerChainId', 'Trigger chain ID is required.');
    }
    validateContractBasics(input.triggerContractAddress, input.abi, input.triggerEvent, 'eventContract');
    if (input.walletMode !== 'safe') {
        validateContractBasics(input.targetContractAddress, input.abi, input.targetFunction, 'contract');
    }
    const isDynamic = argType === 'dynamic' || argType === 2;
    if (isDynamic) {
        if (!isNonEmptyString(input.dynamicArgumentsScriptUrl) || !isValidUrl(input.dynamicArgumentsScriptUrl)) {
            throw new errors_1.ValidationError('contractIpfs', 'IPFS Code URL is required and must be valid for dynamic argument type.');
        }
    }
    else {
        if (input.walletMode !== 'safe') {
            validateStaticArguments(input.abi, input.targetFunction, input.arguments, 'contract');
        }
    }
}
function validateConditionBasedJobInput(input, argType) {
    if (!isNonEmptyString(input.jobTitle)) {
        throw new errors_1.ValidationError('jobTitle', 'Job title is required.');
    }
    if (!input.timeFrame || input.timeFrame <= 0) {
        throw new errors_1.ValidationError('timeframe', 'Timeframe must be a positive number of seconds.');
    }
    if (!isNonEmptyString(input.timezone)) {
        throw new errors_1.ValidationError('timezone', 'Timezone is required.');
    }
    if (!isNonEmptyString(input.chainId)) {
        throw new errors_1.ValidationError('chainId', 'Chain ID is required.');
    }
    // Condition fields
    if (!isNonEmptyString(input.conditionType)) {
        throw new errors_1.ValidationError('contractConditionType', 'Condition type is required.');
    }
    if (!isNonEmptyString(input.valueSourceType)) {
        throw new errors_1.ValidationError('contractSourceType', 'Value source type is required.');
    }
    if (!isNonEmptyString(input.valueSourceUrl) || !isValidUrl(input.valueSourceUrl)) {
        throw new errors_1.ValidationError('contractSourceUrl', 'Source URL is required and must be valid.');
    }
    if (input.conditionType === 'between') {
        if (input.upperLimit === undefined || input.lowerLimit === undefined || input.upperLimit === null || input.lowerLimit === null) {
            throw new errors_1.ValidationError('contractLimits', 'Both upper and lower limits are required.');
        }
    }
    else {
        if (input.upperLimit === undefined || input.upperLimit === null) {
            throw new errors_1.ValidationError('contractLimits', 'Value is required.');
        }
    }
    if (input.walletMode !== 'safe') {
        validateContractBasics(input.targetContractAddress, input.abi, input.targetFunction, 'contract');
    }
    const isDynamic = argType === 'dynamic' || argType === 2;
    if (isDynamic) {
        if (!isNonEmptyString(input.dynamicArgumentsScriptUrl) || !isValidUrl(input.dynamicArgumentsScriptUrl)) {
            throw new errors_1.ValidationError('contractIpfs', 'IPFS Code URL is required and must be valid for dynamic argument type.');
        }
    }
    else {
        if (input.walletMode !== 'safe') {
            validateStaticArguments(input.abi, input.targetFunction, input.arguments, 'contract');
        }
    }
}
function validateJobInput(jobInput, argType) {
    if ('scheduleType' in jobInput) {
        validateTimeBasedJobInput(jobInput, argType);
    }
    else if ('triggerChainId' in jobInput) {
        validateEventBasedJobInput(jobInput, argType);
    }
    else {
        validateConditionBasedJobInput(jobInput, argType);
    }
}
